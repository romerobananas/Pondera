'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = require('react');
var React__default = _interopDefault(React);

const getWindow = () => window;
const getRoutingHash = () => getWindow() ? getWindow().location.hash.replace("#", "") : undefined;
const setRoutingHash = (hashValue) => {
    if (getWindow())
        getWindow().location.hash = hashValue;
};

const WizardContext = React__default.createContext(null);
const useWizard = ({ initialStepIndex = 0, onChange } = {}) => {
    const [activeStepIndex, setActiveStepIndex] = React.useState(initialStepIndex);
    const [maxActivatedStepIndex, setMaxActivatedStepIndex] = React.useState(initialStepIndex - 1);
    const stepTitles = [];
    let stepCheckIndex = 0;
    React.useEffect(() => {
        const hash = getRoutingHash();
        const newStepIndex = stepTitles.indexOf(hash);
        if (newStepIndex >= 0) {
            goToStep(newStepIndex);
        }
    }, []);
    React.useEffect(() => {
        const stepsWithTitle = stepTitles.filter(title => !!title);
        const allStepTitlesAvailable = stepsWithTitle.length === stepCheckIndex;
        const allStepTitlesMissing = stepsWithTitle.length === 0;
        if (allStepTitlesAvailable) {
            const stepTitle = stepTitles[activeStepIndex];
            setRoutingHash(stepTitle);
            return;
        }
        if (!allStepTitlesMissing) {
            const indicesOfMissingTitles = stepTitles
                .map((title, index) => (!title ? index : null))
                .filter(title => title !== null);
            console.warn(`You have not specified a title for the steps with the indices: ${indicesOfMissingTitles.join(", ")}`);
            return;
        }
    }, [activeStepIndex]);
    const getStep = ({ routeTitle } = {}) => {
        const stepIndex = stepCheckIndex;
        stepTitles.push(routeTitle);
        const stepState = {
            index: stepIndex,
            isActive: activeStepIndex === stepCheckIndex,
            hasBeenActive: maxActivatedStepIndex >= stepCheckIndex,
            nextStep: () => goToStep(stepIndex + 1),
            previousStep: () => goToStep(Math.max(stepIndex - 1, 0)),
            resetToStep: () => goToStep(stepIndex, { resetMaxStepIndex: true }),
            moveToStep: () => goToStep(stepIndex)
        };
        stepCheckIndex++;
        return stepState;
    };
    const goToStep = (stepIndex, { resetMaxStepIndex = false } = {}) => {
        if (activeStepIndex !== stepIndex) {
            const newMaxStepIndex = resetMaxStepIndex
                ? stepIndex - 1
                : Math.max(activeStepIndex, maxActivatedStepIndex);
            onChange &&
                onChange({
                    previousStepIndex: activeStepIndex,
                    newStepIndex: stepIndex,
                    maxActivatedStepIndex: newMaxStepIndex
                });
            setActiveStepIndex(stepIndex);
            setMaxActivatedStepIndex(newMaxStepIndex);
        }
    };
    const nextStep = () => {
        goToStep(activeStepIndex + 1);
    };
    const previousStep = () => {
        goToStep(Math.max(activeStepIndex - 1, 0));
    };
    const moveToStep = (stepIndex) => {
        goToStep(stepIndex);
    };
    const resetToStep = (stepIndex) => {
        goToStep(stepIndex, { resetMaxStepIndex: true });
    };
    return {
        activeStepIndex,
        maxActivatedStepIndex,
        goToStep,
        nextStep,
        previousStep,
        getStep,
        moveToStep,
        resetToStep
    };
};
const Wizard = (props) => {
    const internalState = useWizard({
        initialStepIndex: props.initialStepIndex,
        onChange: props.onChange
    });
    return (React__default.createElement(WizardContext.Provider, { value: Object.assign({}, internalState) }, typeof props.children === "function"
        ? props.children(internalState)
        : props.children));
};
const WizardStep = (props) => {
    const wizardContext = React.useContext(WizardContext);
    if (wizardContext === null) {
        throw new Error("Wizard Step must be used as a child within a Wizard Component");
    }
    const contextRef = React.useRef(null);
    const stepRef = React.useRef(null);
    if (contextRef.current !== wizardContext) {
        contextRef.current = wizardContext;
        stepRef.current = wizardContext.getStep({
            routeTitle: props.routeTitle
        });
    }
    return props.children(stepRef.current);
};

exports.useWizard = useWizard;
exports.Wizard = Wizard;
exports.WizardStep = WizardStep;
exports.default = Wizard;
